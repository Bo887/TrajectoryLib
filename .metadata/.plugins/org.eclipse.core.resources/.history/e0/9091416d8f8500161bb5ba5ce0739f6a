public class TrajectoryGenerator{
	
	//Assume start_pos = 0
	double start_vel;
	double end_vel;
	double end_pos; // aka total dist or setpoint
	double max_vel;
	double accel;
	double dt;
	
	//Generates a feedforward trajectory	
	public TrajectoryGenerator(double start_vel, double end_pos, double end_vel, double max_vel, double accel, double dt){
		this.start_vel = start_vel;
		this.end_vel = end_vel;
		this.max_vel = max_vel;
		this.end_pos = end_pos;
		this.accel = accel;
		this.dt = dt;
	}
	
	//Generates a trajectory (list of segments) for the given constraints
	public Segment[] generateTraj(){
		Segment[] traj;
		//Calculates the cruise_velocity for the parameters given depending on the distance to travel
		double start_dist_offset = (0.5*start_vel*start_vel)/accel;
		double end_dist_offset = (0.5*end_vel*end_vel)/accel;
		double adjusted_total_dist = (end_pos-start_dist_offset-end_dist_offset);
		double cruise_vel = Math.min(max_vel, Math.sqrt(accel*adjusted_total_dist));
		//-----Calculates other kinematic values
		double accel_time = (cruise_vel-start_vel)/accel;
		double deaccel_time = (cruise_vel-end_vel)/accel;
		//compute dists
		//dist = initial_dist(0) + initial_vel*time + 1/2*accel*time^2 
		//accel = deaccel
		double accel_dist = (start_vel*accel_time+0.5*accel*accel_time*accel_time); 
		double deaccel_dist = (cruise_vel*deaccel_time + (-0.5)*accel*deaccel_time*deaccel_time);
		double cruise_dist = end_pos-(accel_dist+deaccel_dist);
		double cruise_time = cruise_dist/cruise_vel;
		double total_time = cruise_time+accel_time+deaccel_time;
		int size = (int)(total_time/dt);
		traj = new Segment[size];
		double curr_time = 0;
		System.out.printf("Total Dist: %f   Total Time: %f\n",end_pos, total_time);
		for(int i=0;i<size;i++){
			double curr_pos, curr_vel, curr_accel;
			if (curr_time<accel_time){
				curr_pos = (0.5)*accel*curr_time*curr_time;
				curr_vel = start_vel+accel*curr_time;
				curr_accel = accel;
			}	
			else if (curr_time>accel_time&&curr_time<(accel_time+cruise_time)){
				curr_pos = accel_dist+cruise_vel*(curr_time-accel_time);
				curr_vel = cruise_vel;
				curr_accel = 0;
			}
			else{
				curr_pos = accel_dist+cruise_dist+(0.5*accel*curr_time*curr_time); 
				curr_vel = cruise_vel-(accel*curr_time);
				curr_accel = -accel;
			
			}
			Segment s = new Segment(curr_pos, curr_vel, curr_accel, curr_time);
			traj[i] = s;
			curr_time+=dt;
		}
		return traj;
	}
}